{% extends 'layout_footer.html' %}

{% block content_left %}

    <div class="container d-flex flex-column w-100 h-100">
        <div class="row flex-grow-1" style="overflow: scroll">
            <div class="col h-100">
                <div class="wrap-tree w-100 h-100" id="tree-div">
                </div>
            </div>

        </div>
        <div class="row">
            <div class="col">
                <h2>Kostenabschätung: {{ "%.2f€"|format(prediction) }}</h2>
            </div>
        </div>
    </div>

{% endblock content_left %}


{% block content_right %}

    <div class="card flex-grow-1">
        <div class="card-header">
            <h3>Bauteilspezifikationen</h3>
        </div>
        <div class="card-body">


            <div class="chart-wrap bg list">
            <div class="chart">
                <form method="POST" action="{{url_for('deployment')}}">
                    <fieldset class="form-group">
                        <ul class="slidecontainer">
                            <li><p>Anzahl der Kavitäten</p></li>
                            <div class="range-slider">
                                <input type="range" min="1" max="30"
                                       class="range-slider__range"
                                       id="max_Anzahl_slider" name="max_Anzahl">
                                <span id="max_Anzahl_value"
                                      class="range-slider__value"></span>
                            </div>

                            <li><p>Schieberanzahl</p></li>
                            <div class="range-slider">
                                <input type="range" min="3" max="30"
                                       class="range-slider__range"
                                       id="min_samples_leaf_slider"
                                       name="min_samples_leaf">
                                <span id="min_samples_leaf_value"
                                      class="range-slider__value"></span>
                            </div>
                            <li><p>Größe der Kavitäten</p></li>
                            <div class="range-slider">
                                <input type="range" min="1" max="30"
                                       class="range-slider__range"
                                       id="max_depth_slider" name="max_depth">
                                <span id="max_depth_value"
                                      class="range-slider__value"></span>
                            </div>

                            <li><p>Material Bauteil</p></li>
                            <div class="range-slider">
                                <input type="range" min="3" max="30"
                                       class="range-slider__range"
                                       id="min_Material_leaf_slider"
                                       name="min_Material_leaf">
                                <span id="min_Material_leaf_value"
                                      class="range-slider__value"></span>
                            </div>
                            <li><p>Abmaße des Werkzeugs</p></li>
                            <div class="range-slider">
                                <input type="range" min="1" max="30"
                                       class="range-slider__range"
                                       id="max_Werkzeugs_slider" name="max_Werkzeugs">
                                <span id="max_Werkzeugs_value"
                                      class="range-slider__value"></span>
                            </div>
                    </fieldset>
                    </ul>
                    <button type="button" onclick="predict()"
                    class="btn btn-primary w-100">Kostenabschätzung
                    </button>
                </form>
            </div>
        </div>
        </div>
    </div>
    <script type="text/javascript">
        var m = [10, 120, 10, 120],
            w = 1000 - m[1] - m[3],
            h = 800 - m[0] - m[2],
            i = 0,
            rect_width = 80,
            rect_height = 20,
            max_link_width = 20,
            min_link_width = 1.5,
            char_to_pxl = 6,
            root;

        var tree = d3.layout.tree().size([h, w]);
        d3.json("{{ url_for('static', filename='predict.json') }}", load_dataset);


        var diagonal = d3.svg.diagonal().projection(function (d) {
            return [d.x, d.y];
        });

        var vis = d3.select("#tree-div").append("svg:svg")
            .attr("width", w + m[1] + m[3])
            .attr("height", h + m[0] + m[2] + 1000).append("svg:g")
            .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

        // global scale for link width
        var link_stoke_scale = d3.scale.linear();
        var color_map = d3.scale.category10();
        // stroke style of link - either color or function
        var stroke_callback = "#ccc";

        function load_dataset(json) {
            root = json;

            root.x0 = 0;
            root.y0 = 0;
            var n_samples = root.samples;
            var n_labels = root.value.length;
            if (n_labels >= 2) {
                stroke_callback = mix_colors;
            } else if (n_labels === 1) {
                stroke_callback = mean_interpolation(root);
            }
            link_stoke_scale = d3.scale.linear()
                .domain([0, n_samples])
                .range([min_link_width, max_link_width]);

            function toggleAll(d) {
                if (d && d.children) {
                    d.children.forEach(toggleAll);
                    toggle(d);
                }
            }

            // Initialize the display to show a few nodes.
            root.children.forEach(toggleAll);
            update(root);
        }

        function update(source) {
            var duration = d3.event && d3.event.altKey ? 5000 : 500;
            // Compute the new tree layout.
            var nodes = tree.nodes(root).reverse();
            // Normalize for fixed-depth.
            nodes.forEach(function (d) {
                d.y = d.depth * 180;
            });
            // Update the nodes…
            var node = vis.selectAll("g.node")
                .data(nodes, function (d) {
                    return d.id || (d.id = ++i);
                });
            // Enter any new nodes at the parent's previous position.
            var nodeEnter = node.enter().append("svg:g")
                .attr("class", "node")
                .attr("transform", function (d) {
                    return "translate(" + source.x0 + "," + source.y0 + ")";
                })
                .on("click", function (d) {
                    toggle(d);
                    update(d);
                });
            nodeEnter.append("svg:rect")
                .attr("x", function (d) {
                    var label = node_label(d);
                    var text_len = label.length * char_to_pxl;
                    var width = d3.max([rect_width, text_len])
                    return -width / 2;
                })
                .attr("width", 1e-6)
                .attr("height", 1e-6)
                .attr("rx", function (d) {
                    return d.type === "split" ? 2 : 0;
                })
                .attr("ry", function (d) {
                    return d.type === "split" ? 2 : 0;
                })
                .style("stroke", function (d) {
                    return d.type === "split" ? "steelblue" : "olivedrab";
                })
                .style("fill", function (d) {
                    return d._children ? "lightsteelblue" : "#fff";
                });
            nodeEnter.append("svg:text")
                .attr("dy", "12px")
                .attr("text-anchor", "middle")
                .text(node_label)
                .style("fill-opacity", 1e-6);
            // Transition nodes to their new position.
            var nodeUpdate = node.transition()
                .duration(duration)
                .attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });
            nodeUpdate.select("rect")
                .attr("width", function (d) {
                    var label = node_label(d);
                    var text_len = label.length * char_to_pxl;
                    var width = d3.max([rect_width, text_len])
                    return width;
                })
                .attr("height", rect_height)
                .style("fill", function (d) {
                    return d._children ? "lightsteelblue" : "#fff";
                });
            nodeUpdate.select("text")
                .style("fill-opacity", 1);
            // Transition exiting nodes to the parent's new position.
            var nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", function (d) {
                    return "translate(" + source.x + "," + source.y + ")";
                })
                .remove();
            nodeExit.select("rect")
                .attr("width", 1e-6)
                .attr("height", 1e-6);
            nodeExit.select("text")
                .style("fill-opacity", 1e-6);
            // Update the links
            var link = vis.selectAll("path.link")
                .data(tree.links(nodes), function (d) {
                    return d.target.id;
                });
            // Enter any new links at the parent's previous position.
            link.enter().insert("svg:path", "g")
                .attr("class", "link")
                .attr("d", function (d) {
                    var o = {x: source.x0, y: source.y0};
                    return diagonal({source: o, target: o});
                })
                .transition()
                .duration(duration)
                .attr("d", diagonal)
                .style("stroke-width", function (d) {
                    return link_stoke_scale(d.target.samples);
                })
                .style("stroke", stroke_callback);
            // Transition links to their new position.
            link.transition()
                .duration(duration)
                .attr("d", diagonal)
                .style("stroke-width", function (d) {
                    return link_stoke_scale(d.target.samples);
                })
                .style("stroke", stroke_callback);
            // Transition exiting nodes to the parent's new position.
            link.exit().transition()
                .duration(duration)
                .attr("d", function (d) {
                    var o = {x: source.x, y: source.y};
                    return diagonal({source: o, target: o});
                })
                .remove();
            // Stash the old positions for transition.
            nodes.forEach(function (d) {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }

        // Toggle children.
        function toggle(d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
        }

        // Node labels
        function node_label(d) {

            if (d.type === "leaf") {
                // leaf
                var formatter = d3.format(".2f");
                var vals = [];
                d.value.forEach(function (v) {
                    vals.push(formatter(v));
                });
                return "[" + vals.join(", ") + "]";
            } else {
                // split node
                return d.label;
            }
        }

        /**
         * Mixes colors according to the relative frequency of classes.
         */
        function mix_colors(d) {
            var value = d.target.value;
            var sum = d3.sum(value);
            var col = d3.rgb(0, 0, 0);
            value.forEach(function (val, i) {
                var label_color = d3.rgb(color_map(i));
                var mix_coef = val / sum;
                col.r += mix_coef * label_color.r;
                col.g += mix_coef * label_color.g;
                col.b += mix_coef * label_color.b;
            });
            return col;
        }

        /**
         * A linear interpolator for value[0].
         *
         * Useful for link coloring in regression trees.
         */
        function mean_interpolation(root) {
            var max = 1e-9,
                min = 1e9;

            function recurse(node) {
                if (node.value[0] > max) {
                    max = node.value[0];
                }
                if (node.value[0] < min) {
                    min = node.value[0];
                }
                if (node.children) {
                    node.children.forEach(recurse);
                }
            }

            recurse(root);
            var scale = d3.scale.linear().domain([min, max])
                .range(["#2166AC", "#B2182B"]);

            function interpolator(d) {
                return scale(d.target.value[0]);
            }

            return interpolator;
        }
    </script>

<script>
    const settings = {
        fill: '#1abc9c',
        background: '#d7dcdf'
    }

    const sliders = document.querySelectorAll('.range-slider');
    Array.prototype.forEach.call(sliders,(slider)=>{
      slider.querySelector('input').addEventListener('input', (event)=>{
        slider.querySelector('span').innerHTML = event.target.value % 1 === 0 ? event.target.value: Number.parseFloat(event.target.value).toPrecision(4);
        applyFill(event.target);
      });

    applyFill(slider.querySelector('input'));
    })
    ;

    function applyFill(slider) {
        const percentage = 100 * (slider.value - slider.min) / (slider.max - slider.min);
        const bg = `linear-gradient(90deg, ${settings.fill} ${percentage}%, ${settings.background} ${percentage + 0.1}%)`;
        slider.style.background = bg;
    }
</script>
{% endblock content_right %}