{% extends 'layout_footer.html' %}

{% block content_left %}

    <div class="container d-flex flex-column w-100 h-100">
        <div class="row flex-grow-1" style="overflow: scroll">
            <div class="col">
                <div class="wrap-tree w-100 h-100" id="tree-div">
                </div>
            </div>

        </div>
        <div class="row" >
            <div class="col">
                <h5>Durchschnittliche Abweichung: {{ "%.2f€"|format(mean_absolute_error) }}</h5>
            </div>

            <button type="button" class="btn btn-primary" id="expand_button" style="float: right; height: 40px">Expand all</button>

            <button type="button" class="btn btn-primary" id="collapse_button" style="float: right; height: 40px">Collapse all</button>

        </div>
    </div>
{% endblock content_left %}


{% block content_right %}

    <div class="card flex-grow-1">
{#        <div class="card-header">#}
{#            <h4>Erläuterung</h4>#}
{#        </div>#}


        <div class="card-body bg list">
            <div class="chart">
            <ul>
                <li class="list-item">Aufteilung der Daten in Training-
                    und Testdaten.
                </li>

                <li class="list-item">Training von Modellen mit
                    unterschiedlichen Parametern.
                </li>

{#                <li class="list-group-item">Auswahl und Training eines Models#}
{#                    auf Trainingsdaten#}
{#                </li>#}
{#                <li class="list-item">Evaluation durch Testdatensatz#}
{#                </li>#}
            </ul>
            </div>
        </div>
    </div>

    <div class="card flex-grow-1">
        <div class="card-header">
            <span><h4>Trainingsparameter</h4></span>
            <button type="button" class="btn btn-primary" id="pop_train_info" style="float: right; height: 30px">info</button>
        </div>
        <div class="card-body bg list">
    <div class="chart">
            <ul >
                <li class="list-item">
                    <h5>
                        Anzahl Trainingsdaten [%]
                    </h5>
                    <div class="range-slider">
                        <input id="range_train_size" class="range-slider__range" type="range"
                               value="{{ "%.0f"|format(train_size * 100) }}"
                               min="10" max="90" step="10">
                        <span class="range-slider__value"></span>
                    </div>
                </li>
                <li class="list-item">
                    <h5>
                        Maximale Baumtiefe
                    </h5>
                    <div class="range-slider">
                        <input id="range_max_depth" class="range-slider__range" type="range"
                               value="{{ "%.0f"|format(max_depth) }}" min="1"
                               max="50" step="1">
                        <span class="range-slider__value">0</span>
                    </div>
                </li>
                {#                <li class="list-item">#}
                {#                    <h5>#}
                {#                        Maximale Blattgröße#}
                {#                    </h5>#}
                {#                    <div class="range-slider">#}
                {#                        <input class="range-slider__range" type="range"#}
                {#                               value="{{ "%.0f"|format(min_samples_leaf) }}" min="1" max="50" step="1">#}
                {#                        <span class="range-slider__value">0</span>#}
                {#                    </div>#}
                {#                </li>#}
            </ul>

            <button type="button" onclick="train()"
                    class="btn btn-primary w-100">Trainieren
            </button>
        </div>
        </div>
    </div>


    <script type="text/javascript">
        var m = [10, 120, 10, 120],
            w = 1000 - m[1] - m[3],
            h = 800 - m[0] - m[2],
            i = 0,
            rect_width = 80,
            rect_height = 20,
            max_link_width = 20,
            min_link_width = 1.5,
            char_to_pxl = 6,
            root;

        var tree = d3.layout.tree().size([h, w]);

        var tree_filename = 'output-' + '{{ timestamp }}' + '.json'
        var tree_filepath = "/static/" + tree_filename

        d3.json(tree_filepath, load_dataset);


        var diagonal = d3.svg.diagonal().projection(function (d) {
            return [d.x, d.y];
        });

        var vis = d3.select("#tree-div").append("svg:svg")
            .attr("width", w + m[1] + m[3])
            .attr("height", h + m[0] + m[2] + 1000)
            .append("svg:g")
            .attr("class", "drawarea")
            .append("svg:g")
            .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

        // global scale for link width
        var link_stoke_scale = d3.scale.linear();
        var color_map = d3.scale.category10();
        // stroke style of link - either color or function
        var stroke_callback = "#ccc";

        function load_dataset(json) {
            root = json;

            root.x0 = 0;
            root.y0 = 0;
            var n_samples = root.samples;
            var n_labels = root.value.length;
            if (n_labels >= 2) {
                stroke_callback = mix_colors;
            } else if (n_labels === 1) {
                stroke_callback = mean_interpolation(root);
            }
            link_stoke_scale = d3.scale.linear()
                .domain([0, n_samples])
                .range([min_link_width, max_link_width]);

            function toggleAll(d) {
                if (d && d.children) {
                    d.children.forEach(toggleAll);
                    toggle(d);
                }
            }

            // Initialize the display to show a few nodes.
            root.children.forEach(toggleAll);
            update(root);
        }

        function update(source) {
            var duration = d3.event && d3.event.altKey ? 5000 : 500;
            // Compute the new tree layout.
            var nodes = tree.nodes(root).reverse();
            // Normalize for fixed-depth.
            nodes.forEach(function (d) {
                d.y = d.depth * 180;
            });
            // Update the nodes…
            var node = vis.selectAll("g.node")
                .data(nodes, function (d) {
                    return d.id || (d.id = ++i);
                });
            // Enter any new nodes at the parent's previous position.
            var nodeEnter = node.enter().append("svg:g")
                .attr("class", "node")
                .attr("transform", function (d) {
                    return "translate(" + source.x0 + "," + source.y0 + ")";
                })
                .on("click", function (d) {
                    toggle(d);
                    update(d);
                });
            nodeEnter.append("svg:rect")
                .attr("x", function (d) {
                    var label = node_label(d);
                    var text_len = label.length * char_to_pxl;
                    var width = d3.max([rect_width, text_len])
                    return -width / 2;
                })
                .attr("width", 1e-6)
                .attr("height", 1e-6)
                .attr("rx", function (d) {
                    return d.type === "split" ? 2 : 0;
                })
                .attr("ry", function (d) {
                    return d.type === "split" ? 2 : 0;
                })
                .style("stroke", function (d) {
                    return d.type === "split" ? "steelblue" : "olivedrab";
                })
                .style("fill", function (d) {
                    return d._children ? "lightsteelblue" : "#fff";
                });
            nodeEnter.append("svg:text")
                .attr("dy", "12px")
                .attr("text-anchor", "middle")
                .text(node_label)
                .style("fill-opacity", 1e-6);
            // Transition nodes to their new position.
            var nodeUpdate = node.transition()
                .duration(duration)
                .attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });
            nodeUpdate.select("rect")
                .attr("width", function (d) {
                    var label = node_label(d);
                    var text_len = label.length * char_to_pxl;
                    var width = d3.max([rect_width, text_len])
                    return width;
                })
                .attr("height", rect_height)
                .style("fill", function (d) {
                    return d._children ? "lightsteelblue" : "#fff";
                });
            nodeUpdate.select("text")
                .style("fill-opacity", 1);
            // Transition exiting nodes to the parent's new position.
            var nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", function (d) {
                    return "translate(" + source.x + "," + source.y + ")";
                })
                .remove();
            nodeExit.select("rect")
                .attr("width", 1e-6)
                .attr("height", 1e-6);
            nodeExit.select("text")
                .style("fill-opacity", 1e-6);
            // Update the links
            var link = vis.selectAll("path.link")
                .data(tree.links(nodes), function (d) {
                    return d.target.id;
                });
            // Enter any new links at the parent's previous position.
            link.enter().insert("svg:path", "g")
                .attr("class", "link")
                .attr("d", function (d) {
                    var o = {x: source.x0, y: source.y0};
                    return diagonal({source: o, target: o});
                })
                .transition()
                .duration(duration)
                .attr("d", diagonal)
                .style("stroke-width", function (d) {
                    return link_stoke_scale(d.target.samples);
                })
                .style("stroke", stroke_callback);
            // Transition links to their new position.
            link.transition()
                .duration(duration)
                .attr("d", diagonal)
                .style("stroke-width", function (d) {
                    return link_stoke_scale(d.target.samples);
                })
                .style("stroke", stroke_callback);
            // Transition exiting nodes to the parent's new position.
            link.exit().transition()
                .duration(duration)
                .attr("d", function (d) {
                    var o = {x: source.x, y: source.y};
                    return diagonal({source: o, target: o});
                })
                .remove();
            // Stash the old positions for transition.
            nodes.forEach(function (d) {
                d.x0 = d.x;
                d.y0 = d.y;
            });

            d3.select("svg")
        .call(d3.behavior.zoom()
              .scaleExtent([0.5, 5])
              .on("zoom", zoom));
        }

        function zoom() {
            var scale = d3.event.scale,
            translation = d3.event.translate,
            tbound = -h * scale,
            bbound = h * scale,
            lbound = (-w + m[1]) * scale,
            rbound = (w - m[3]) * scale;
            // limit translation to thresholds
            translation = [
            Math.max(Math.min(translation[0], rbound), lbound),
            Math.max(Math.min(translation[1], bbound), tbound)
            ];
            d3.select(".drawarea")
                .attr("transform", "translate(" + translation + ")" +
                " scale(" + scale + ")");
}


        // Toggle children.
        function toggle(d) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
        }

        // Node labels
        function node_label(d) {

            if (d.type === "leaf") {
                // leaf
                var formatter = d3.format(".2f");
                var vals = [];
                d.value.forEach(function (v) {
                    vals.push(formatter(v));
                });
                return "[" + vals.join(", ") + "]";
            } else {
                // split node
                return d.label;
            }
        }

        /**
         * Mixes colors according to the relative frequency of classes.
         */
        function mix_colors(d) {
            var value = d.target.value;
            var sum = d3.sum(value);
            var col = d3.rgb(0, 0, 0);
            value.forEach(function (val, i) {
                var label_color = d3.rgb(color_map(i));
                var mix_coef = val / sum;
                col.r += mix_coef * label_color.r;
                col.g += mix_coef * label_color.g;
                col.b += mix_coef * label_color.b;
            });
            return col;
        }

        /**
         * A linear interpolator for value[0].
         *
         * Useful for link coloring in regression trees.
         */
        function mean_interpolation(root) {
            var max = 1e-9,
                min = 1e9;

            function recurse(node) {
                if (node.value[0] > max) {
                    max = node.value[0];
                }
                if (node.value[0] < min) {
                    min = node.value[0];
                }
                if (node.children) {
                    node.children.forEach(recurse);
                }
            }

            recurse(root);
            var scale = d3.scale.linear().domain([min, max])
                .range(["#2166AC", "#B2182B"]);

            function interpolator(d) {
                return scale(d.target.value[0]);
            }

            return interpolator;
        }

        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = null;
            }
        }

        function expand(d) {
            if (d._children) {
                d.children = d._children;
                d.children.forEach(expand);
                d._children = null;
            }
         }


        $("#expand_button").click(function(){
            root.children.forEach(expand);
            update(root);
         });


         $("#collapse_button").click(function(){
            root.children.forEach(collapse);
            update(root);
         });

    </script>

    <script>

        function train() {
            var max_depth = document.getElementById("range_max_depth").value
            var train_size = document.getElementById("range_train_size").value / 100

            window.location = '{{ url_for('training') }}?max_depth=' + max_depth + '&train_size=' + train_size;

            console.log(max_depth, train_size)
        }

        var rangeSlider = function () {
            var slider = $('.range-slider'),
                range = $('.range-slider__range'),
                value = $('.range-slider__value');

            console.log(slider)

            slider.each(function () {


                value.each(function () {
                    var value = $(this).prev().attr('value');
                    $(this).html(value);
                });

                range.on('input', function () {
                    $(this).next(value).html(this.value);
                });
            });
        };

        rangeSlider();

        $(window).load(function () {
    $("#pop_train_info").click(function(){
       $('#train_popwindow').show();
    });
    $('#closebutton_train').click(function(){
        $('#train_popwindow').hide();
    });
});
    </script>
{% endblock content_right %}